Primeiros passos quando criar uma api em node.js

1 - git init
2 - npm init -y ( Com o -y ele já cria o package.json com conifgurações padrão)
3 - npm i -D typescript @types/node
4 - criar o arquivo tsconfig.json na raiz do projeto
5 - instalar eslint-config-standard-with-typescript (Pegar npm instal no repositório do github)
6 - criar o arquivo .eslintrc.json
7 - criar arquivo .eslintignore
8 - adicionar husky no projeto - npm i -D husky
9 - criar arquivo .huskyrc.json
10 - adicionar lint-staged - npm i -D lint-staged
11 - criar arquivo .lintstagedrc.json
12 - adicionar jest no projeto - npm i -D jest @types/jest ts-jest
12 - rodar npx jest --init
13 - criar um arquivo teste e rodar npm test


Sempre criar erros personalizados, extendendo a classe Error do JavaScript
1 - Basta criar uma pasta errors
2 - Criar o arquivo .ts
3 - Criar a função, extender de Error e usar super() e this
4 - Criar tambem uma pasta helper e um file ts, que retornar o erro como objeto, com o nome do erro
Ex-> 400 é um badRequest

Sintax sugar
O monstro manguinho transformou isso:
    if (!httpRequest.body.name) {
      return badRequest(new MissingParamError('name'))
    }

    if (!httpRequest.body.email) {
      return badRequest(new MissingParamError('email'))
    }

em isso:
    const requiredField = ['name', 'email']
    for (const field of requiredField) {
      if (!httpRequest.body[field]) {
        return badRequest(new MissingParamError(field))
      }
    }
  }

  SOLID
  S -Single responsability principle - Isolar cada classe e função e cada um vai fazer uma coisa.
  I - Interface segregation principle - Criamos interfaces que fazem apenas uma coisa, assim uma classe pode utilizar várias interfaces,
  e cada interface faz uma coisa diferente

  Teste unitário - JEST
  Utiliza com a extensão .spec Exemplo --> signup.spec.ts


  Teste de integração - JEST
  Utiliza com a extensão .test Exemplo --> signup.test.ts

  O JEST entende sozinho essa nomenclatura acima, ele já sabe que é o teste.
  