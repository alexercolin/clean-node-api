Primeiros passos quando criar uma api em node.js
Até o passso 13, foi tudo feito antes de iniciar o projeto, o resto, foi durante.

1 - git init
2 - npm init -y ( Com o -y ele já cria o package.json com conifgurações padrão)
3 - npm i -D typescript @types/node
4 - criar o arquivo tsconfig.json na raiz do projeto
5 - instalar eslint-config-standard-with-typescript (Pegar npm instal no repositório do github)
6 - criar o arquivo .eslintrc.json
7 - criar arquivo .eslintignore
8 - adicionar husky no projeto - npm i -D husky
9 - criar arquivo .huskyrc.json
10 - adicionar lint-staged - npm i -D lint-staged
11 - criar arquivo .lintstagedrc.json
12 - adicionar jest no projeto - npm i -D jest @types/jest ts-jest
12 - rodar npx jest --init
13 - criar um arquivo teste e rodar npm test
14 - Depois de um tempo, foi instalado o bcrypt, com npm i bcrypt (É uma dependência de produção)
15 - Depois npm i @types/bcrypt -D, esse sim como desenvolvimento, apenas para suporte ao typescript
16 - Foi instalado o shelf, que faz testes de integração com o mongodb - npm i -D @shelf/jest-mongodb
17 - E também foi instalado o mongodb npm i mongodb (DEPENDÊNCIA DE PRODUÇÃO) e dps o @types/mongodb como DEPENDÊNCIA DE DESENVOLVIMENTO


Sempre criar erros personalizados, extendendo a classe Error do JavaScript
1 - Basta criar uma pasta errors
2 - Criar o arquivo .ts
3 - Criar a função, extender de Error e usar super() e this
4 - Criar tambem uma pasta helper e um file ts, que retornar o erro como objeto, com o nome do erro
Ex-> 400 é um badRequest

Sintax sugar
O monstro manguinho transformou isso:
    if (!httpRequest.body.name) {
      return badRequest(new MissingParamError('name'))
    }

    if (!httpRequest.body.email) {
      return badRequest(new MissingParamError('email'))
    }

em isso:
    const requiredField = ['name', 'email']
    for (const field of requiredField) {
      if (!httpRequest.body[field]) {
        return badRequest(new MissingParamError(field))
      }
    }
  }

  SOLID
  S -Single responsability principle - Isolar cada classe e função e cada um vai fazer uma coisa.
  I - Interface segregation principle - Criamos interfaces que fazem apenas uma coisa, assim uma classe pode utilizar várias interfaces,
  e cada interface faz uma coisa diferente

  Teste unitário - JEST
  Utiliza com a extensão .spec Exemplo --> signup.spec.ts


  Teste de integração - JEST
  Utiliza com a extensão .test Exemplo --> signup.test.ts

  O JEST entende sozinho essa nomenclatura acima, ele já sabe que é o teste.

  Quando for instalar uma dependência
  Exemplo -> npm i validator
  Após o download,
  rodar o npm -i @types/validator -D (Tem que colocar o -D, para ser apenas no ambiente de desenvolvimento)
  O @types é do typescript, para neste caso, reconhecer os tipos do validator.
  
  Nos testes do JEST em caso de sucesso, você não mocka com stub, spyOn, etc..
  O default do mock ja é o caso de sucesso.
  Só mockamos quando quisermos retornar erro

  Isso
  const account = await this.addAccountRepository.add(Object.assign({}, accountData, { password: hashedPassword }))
  Pode ser substituído, por isso:
  const account = await this.addAccountRepository.add({ ...accountData, password: hashedPassword })

  Na interface, você não coloca que é async/await, coloca somente na implementação do método
  Exemplo 

  Interface

  export interface Encrypter {
  encrypt: (value: string) => Promise<string>
}

Implementação do método 

import { Encrypter } from '../../data/protocols/encrypter'
export class BCryptAdapter implements Encrypter {
  async encrypt (value: string): Promise<string> {
    return ''
  }
}

DEPENDÊNCIAS
Aconteceu um caso, o bcrypt ele precisa receber um value e um saltNumber, mas não é todo biblioteca
de criptografia que precisa de um salt, e para funcionar meu test e a minha classe de produção,
eu precisaria receber esse salt como parametro e também coloca-lo na interface.
Mas isso não é legal, por que a minha interface é genérica para criptografia, se eu fizer isso,
estarei fazendo o meu código depender da do bcrypt, que é uma dependência externa.
Então, ao invés disso, eu passo no construtor da classe o salt como se fosse uma
dependência da classe e utilizo nos métodos dessa classe. Isso é uma dependency injection

PONTO DE ATENÇÃO - BANCO DE DADOS
Tanto no trabalho, quanto em projetos pessoais. Atenção a versão do banco de dados 
que você está utilizando em desenvolvimento x produção, elas tem que ser iguais,
e quem define a versão? O SERVIDOR ! Se o servidor só aceitar por exemplo,
a versão do mongodb 4.0.2, tanto a sua versão de desenvolvimento, quanto de produção,
devem estar na mesma versão. Se por acaso você estiver usando em desenvolvimento a versão 
4.0.3, pode ser que recursos dessa versão que você esteja utilizando na sua query, não funcione
em produção, por que esses recursos são somente na versão atual.

GIT 
Comando legal -> git stash /caminho/do/arquivo, você coloca o arquivo que você quiser em uma especie de esconderijo 
ai o git não enxerga ele, e depois para tirar, só dar um git stash pop
Se quiser verificar quais arquivos estão em stash -> git stash list

