Primeiros passos quando criar uma api em node.js

1 - git init
2 - npm init -y ( Com o -y ele já cria o package.json com conifgurações padrão)
3 - npm i -D typescript @types/node
4 - criar o arquivo tsconfig.json na raiz do projeto
5 - instalar eslint-config-standard-with-typescript (Pegar npm instal no repositório do github)
6 - criar o arquivo .eslintrc.json
7 - criar arquivo .eslintignore
8 - adicionar husky no projeto - npm i -D husky
9 - criar arquivo .huskyrc.json
10 - adicionar lint-staged - npm i -D lint-staged
11 - criar arquivo .lintstagedrc.json
12 - adicionar jest no projeto - npm i -D jest @types/jest ts-jest
12 - rodar npx jest --init
13 - criar um arquivo teste e rodar npm test
14 - Depois de um tempo, foi instalado o bcrypt, com npm i bcrypt (É uma dependência de produção)
15 - Depois npm i @types/bcrypt -D, esse sim como desenvolvimento, apenas para suporte ao typescript

Sempre criar erros personalizados, extendendo a classe Error do JavaScript
1 - Basta criar uma pasta errors
2 - Criar o arquivo .ts
3 - Criar a função, extender de Error e usar super() e this
4 - Criar tambem uma pasta helper e um file ts, que retornar o erro como objeto, com o nome do erro
Ex-> 400 é um badRequest

Sintax sugar
O monstro manguinho transformou isso:
    if (!httpRequest.body.name) {
      return badRequest(new MissingParamError('name'))
    }

    if (!httpRequest.body.email) {
      return badRequest(new MissingParamError('email'))
    }

em isso:
    const requiredField = ['name', 'email']
    for (const field of requiredField) {
      if (!httpRequest.body[field]) {
        return badRequest(new MissingParamError(field))
      }
    }
  }

  SOLID
  S -Single responsability principle - Isolar cada classe e função e cada um vai fazer uma coisa.
  I - Interface segregation principle - Criamos interfaces que fazem apenas uma coisa, assim uma classe pode utilizar várias interfaces,
  e cada interface faz uma coisa diferente

  Teste unitário - JEST
  Utiliza com a extensão .spec Exemplo --> signup.spec.ts


  Teste de integração - JEST
  Utiliza com a extensão .test Exemplo --> signup.test.ts

  O JEST entende sozinho essa nomenclatura acima, ele já sabe que é o teste.

  Quando for instalar uma dependência
  Exemplo -> npm i validator
  Após o download,
  rodar o npm -i @types/validator -D (Tem que colocar o -D, para ser apenas no ambiente de desenvolvimento)
  O @types é do typescript, para neste caso, reconhecer os tipos do validator.
  
  Nos testes do JEST em caso de sucesso, você não mocka com stub, spyOn, etc..
  O default do mock ja é o caso de sucesso.
  Só mockamos quando quisermos retornar erro

  Isso
  const account = await this.addAccountRepository.add(Object.assign({}, accountData, { password: hashedPassword }))
  Pode ser substituído, por isso:
  const account = await this.addAccountRepository.add({ ...accountData, password: hashedPassword })

  Na interface, você não coloca que é async/await, coloca somente na implementação do método
  Exemplo 

  Interface

  export interface Encrypter {
  encrypt: (value: string) => Promise<string>
}

Implementação do método 

import { Encrypter } from '../../data/protocols/encrypter'
export class BCryptAdapter implements Encrypter {
  async encrypt (value: string): Promise<string> {
    return ''
  }
}

DEPENDÊNCIAS
Aconteceu um caso, o bcrypt ele precisa receber um value e um saltNumber, mas não é todo biblioteca
de criptografia que precisa de um salt, e para funcionar meu test e a minha classe de produção,
eu precisaria receber esse salt como parametro e também coloca-lo na interface.
Mas isso não é legal, por que a minha interface é genérica para criptografia, se eu fizer isso,
estarei fazendo o meu código depender da do bcrypt, que é uma dependência externa.
Então, ao invés disso, eu passo no construtor da classe o salt como se fosse uma
dependência da classe e utilizo nos métodos dessa classe. Isso é uma dependency injection
